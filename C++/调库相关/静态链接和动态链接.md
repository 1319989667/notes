静态链接意味着库实际上基本被放入`.exe`文件中。

而动态链接是在运行时被链接的。打包运行文件时需要带dll文件一起。



通常静态链接在程序运行的时候是更快的，因为有几个优化可以使用。



# 动态链接

首先，必须保证[include的附加录路径设置完毕，且dll相关的lib文件已经加在链接器附加库和目录里](使用库.txt)，做好这步后我们运行程序会发现加载dll失败。

针对这个问题，可以把dll文件放在`.exe`文件的同级目录那里。

如果使用 lib + dll，就不需要 `declspec(dllimport)`，因为所有要导入的函数或变量都已在 lib 中定义为指针；但如果使用 LoadLibary API 来导入 dll，使用 `declspec(dllimport)`，就可以告诉编译器要导入哪个函数或变量，这将缩短导入时间。



# 静态链接

现在，假设我们构建了两个项目，一个项目是Game，它输出是exe，另一个项目是Engine，它输出是lib。

那么我们在Game里如何调用Engine中的函数呢？

这里提供了几个方法。

1. 去寻找Engine所在的函数声明的文件相对于当前的Game目录的相对目录，直接include。例如`#include "../../Engine/src/Engine.h" `但是！相对路径一点都不理想。
2. 常规我们会使用绝对路径。在Game项目右键属性-> C/C++ -> 常规 ->附加包含目录里写下以`$(SolutionDir)`打头的绝对路径，例如：`$(SolutionDir)Engine\src;` 这样以后我们只需要在头文件那里写`#include "Engine.h"`

编译成功以后会发现链接失败。

我尝试的方法是：右键属性->链接器->输入里添加附加依赖项 例如`Engine.lib`，然后在属性->链接器->常规的附加库目录里添加相应的lib前的路径例如`$(SolutionDir)Debug`。这样可以链接成功。

但是！因为这里的lib是我们Visual Studio生成的，可以让编译器自动帮我们干这件事。

我们右键Game项目，添加->引用，把需要的项目勾选，点击OK。这样做的好处在于，编译器每次编译项目的时候会自动帮我们编译依赖的项目，以随时保持项目是最新代码。



那为什么我们会新建不同的项目模块呢？ 因为有可能多个项目都需要依赖于同一个模块的代码。（比如说多个游戏共享同一个游戏引擎）